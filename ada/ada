#!/usr/bin/env bash

# ADA - Advanced dCache API tool to manage data stored in dCache.
#
# Design: Natalie & Onno, SURFsara.
#
# Latest version is available at: https://github.com/sara-nl/SpiderScripts
#
# Changes:
# 2024-11-26 - Haili   - Add --recursive to --mkdir
# 2024-09-12 - Haili   - Added bulk requests for staging and unstaging
# 2024-08-24 - Haili   - Added option to use env var BEARER_TOKEN
# 2020-11-04 - Onno    - Added link to Natalie's demo video
# 2020-09-22 - Onno    - Support environment variables (ada_<variable>)
# 2020-09-02 - Onno    - Added --space to get poolgroup capacity
# 2020-08-23 - ahaupt  - Use env vars X509_USER_PROXY and X509_CERT_DIR if set
# 2020-05-28 - Onno    - Allow curl options to be overridden in config files
# 2020-04-21 - Onno    - Improved error handling
# 2020-04-16 - Onno    - Add --recursive to --stage, --unstage, --checksum
# 2020-04-03 - Onno    - Add --stat to get all possible file/dir info
# 2020-03-13 - Onno    - Get server-sent events for files being staged
# 2020-03-11 - Onno    - Added recursive deletes
# 2020-03-04 - Onno    - Added X509 proxy authentication and netrc authentication
# 2020-02-24 - Onno    - Don't show bearer tokens on command line
# 2020-02-18 - Onno    - Recursion with server-sent events
# 2020-02-14 - Onno    - Support for server-sent events
# 2020-01-28 - Onno    - Created

usage() {
  cat <<-EOF
	ADA - Advanced dCache API tool to manage your data in dCache.
	Usage: $0 [general options...] [authentication] <command> [command options]
	
	Demo video at https://www.youtube.com/watch?v=Bh0kpTcUUcw .

	General options:

	  --api
	      The dCache API URL to talk to.

	  --debug
	      Show what's going on.

	Authentication options:

	  --tokenfile <filename>
	      Authenticate with the token in this file.
	      This can be an rclone config file with a
	      bearer_token statement, or a plain file with
	      only the token.

	  --netrc [filename]
	      Authenticate with a curl netrc file
	      containing username and password.
	      If no filename was provided, use ~/.netrc.

	  --proxy [filename]
	      Authenticate with a Grid proxy.
	      If no filename was provided, use \$X509_USER_PROXY.

    If no authentication method is specified, \$BEARER_TOKEN is used if it exists. 

	Commands:

	  --help
	      Show this helptext.

	  --whoami
	      Show how dCache identifies you.

	  --list <directory>
	      List a directory.

	  --longlist <file|directory>
	      List a file or directory with details.
	  --longlist --from-file <file-list>
	      List the files or directories specified in the given file.

	  --stat <file|directory>
	      Show all details of file or dir.

	  --mkdir <directory> [--recursive]
	      Create a directory.
	      To recursively create a directory and ALL of its
	      parents, add --recursive. For safety, the maximum number 
	      of directories that can be created at once is 10.

	  --mv <file|directory> <destination>
	      Rename or move a file or directory.

	  --delete <file|directory> [--recursive [--force]]
	      Delete a file or directory.
	      To recursively delete a directory and ALL of its
	      contents, add --recursive. You will need to confirm
	      deletion of each subdir, unless you add --force.
	      Please note, that dCache storage systems usually
	      don't have an undelete option.

	  --checksum <file>
	      Show MD5/Adler32 checksums for file.
	  --checksum <directory> [--recursive]
	      Show MD5/Adler32 checksums for files in directory.
	  --checksum --from-file <file-list>
	      Show MD5/Adler32 checksums for files in the list.

	  --stage <file> [--lifetime <duration>]
	      Stage a file from tape (restore, bring it online).
	      With --lifetime the pin lifetime duration, e.g. 7D.
	      Allowed units are S, M, H or D, standing for seconds, 
	      minutes, hours, or days. 
	      If --lifetime is not given, default is 7D.
	  --stage <directory> [--recursive]
	      Stage files in directory.
	  --stage --from-file <file-list>
	      Stage files or directories in the list.

	  --unstage <file>
	      Release file so dCache may purge its online replica.
	  --unstage <directory> [--recursive]
	      Release files in directory.
	  --unstage --from-file <file-list>
	      Release files in the list.

	  --events <channel-name> <path-to-follow> [--recursive] [--timeout s]
	      Subscribe to changes in the given direcory,
	      using server-sent events (SSE).
	      When --recursive is added, all subdirectories will be
	      followed as well, including any new subdirectories
	      that will be created.
	      With --timeout a timeout in seconds can be set. When
	      a channel is not being followed, dCache may clean it up
	      after this timeout. Events that have not been processed
	      will then be lost.

	  --report-staged <channel-name> <path-to-follow> [--recursive] [--timeout s]
	      Subscribe to stage (bring online) events in a directory,
	      using server-sent events (SSE).
	      This command is slightly different from --events:
	      When you start it, all files in the scope will be listed,
	      including their locality and QoS. This allows your event
	      handler to take actions, like starting jobs to process
	      the files that are online.
	      When all files have been listed, the command will keep
	      listening and reporting all locality and QoS changes.
	      The --recursive and --timeout flags work as with --events.

	  --channels [channel-name]
	      List your existing channels and their properties.
	      If the channel name is given, list channel(s) with that name.

	  --space [poolgroup]
	      Shows total, free, precious and removable space in a poolgroup.
	      If no poolgroup is specified, lists all poolgroups.
	      Available space = free + removable. This command will show that:
	      "ada ... --space mypoolgroup | jq '.free + .removable'"
	      The pinned (sticky) capacity can be calculated with:
	      "ada ... | jq '.total - .free - .precious - .removable'"


	Configuration files:
	
	  Default values can be stored in /etc/ada.conf and ~/.ada/ada.conf.
	  For example:
	  api='https://prometheus.desy.de:3880/api/v1/'
	
	
	Environment variables:
	  
	  Ada will use these environment variables if they exist (in order of precedence):
	    BEARER_TOKEN
	    ada_tokenfile       => --tokenfile  
	    ada_netrcfile       => --netrcfile
	    ada_api             => --api
	    ada_debug           => --debug
	    ada_channel_timeout => --timeout
	    X509_USER_PROXY
	    X509_CERT_DIR
	    
	  You may need to export them, like:
	    export ada_debug=true ; ada ...
	  
	  Environment variables override values from configuration files, 
	  but not from the command line.
	  So the order of precedence is:
	    1. command line arguments
	    2. environment variables
	    3. ~/.ada/ada.conf
	    4. /etc/ada.conf


	Examples:
	  $0 ... (todo)



	EOF
  exit 1
}


# Set default values
api=
debug=false
dry_run=false
channel_timeout=3600
auth_method=
certdir=${X509_CERT_DIR:-/etc/grid-security/certificates}
lifetime=7
lifetime_unit=D
from_file=false
counter=0

# Default options to curl for various activities;
# these can be overidden in configuration files, see below.
# Don't override them unless you know what you're doing.
curl_options_common=(
                      -H "accept: application/json"
                      --fail --silent --show-error
                    )
curl_options_no_errors=(
                      -H "accept: application/json"
                      --fail --silent
                    )
curl_options_post=(
                    -H "content-type: application/json"
                  )
curl_options_stream=(
                      -H 'accept: text/event-stream'
                      --no-buffer
                      --fail --silent --show-error
                    )


# Load defaults from configuration file if exists
declare -a configfiles=( /etc/ada.conf ~/.ada/ada.conf )
for configfile in "${configfiles[@]}" ; do
  if [ -f "$configfile" ] ; then
    $debug && echo "Loading $configfile"
    source "$configfile"
  fi
done

# If no arguments are provided, show help.
if [ -z "$1" ] ; then
  usage
fi

# Process environment vars (they take precedence over config files)
if [ -n "$ada_channel_timeout" ] ; then
  channel_timeout="$ada_channel_timeout"
fi
if [ -n "$ada_debug" ] ; then
  debug="$ada_debug"
fi
if [ -n "$ada_api" ] ; then
  api="$ada_api"
fi
if [ -n "$ada_netrcfile" ] ; then
  netrcfile="$ada_netrcfile"
  auth_method=netrc
fi
if [ -n "$ada_tokenfile" ] ; then
  tokenfile="$ada_tokenfile"
  auth_method=token
fi
if [ -n "$BEARER_TOKEN" ] ; then
  token="$BEARER_TOKEN"
  auth_method=token
fi

# Initialize some vars we don't want to be overridden
script_dir=$(dirname "$0")
command=
path=
recursive=false
force=false

# Process command line arguments
while [ $# -gt 0 ] ; do
  case "$1" in
    --help | -help | -h )
      usage
      ;;
    --tokenfile )
      auth_method=token
      tokenfile="$2"
      shift ; shift
      ;;
    --netrc )
      auth_method=netrc
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a file name
          netrcfile=~/.netrc
          ;;
        * )
          # This must be a file name
          netrcfile="$2"
          shift
          ;;
      esac
      shift
      ;;
    --proxy )
      auth_method=proxy
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a file name
          proxyfile="${X509_USER_PROXY:-/tmp/x509up_u${UID}}"
          ;;
        * )
          # This must be a file name
          proxyfile="$2"
          shift
          ;;
      esac
      shift
      ;;
    --api )
      api="$2"
      shift ; shift
      ;;
    --whoami )
      command='whoami'
      shift
      ;;
    --list )
      command='list'
      path="$2"
      shift ; shift
      ;;
    --longlist )
      command='longlist'
      if [ "$2" = "--from-file" ] ; then
        $debug && echo "Reading list '$3'"
        pathlist=$(<"$3")
        shift ; shift ; shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --stat )
      command='stat'
      path="$2"
      shift ; shift
      ;;
    --mkdir )
      command='mkdir'
      path="$2"
      shift ; shift
      ;;
    --mv )
      command='mv'
      path="$2"
      destination="$3"
      shift ; shift ; shift
      ;;
    --delete )
      command='delete'
      path="$2"
      shift ; shift
      ;;
    --checksum )
      command='checksum'
      if [ "$2" = "--from-file" ] ; then
       	pathlist=$(<"$3")
        shift ; shift ; shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --stage )
      command='stage'
      if [[ $2 =~ ^--from-?file ]] ; then
        from_file=true
        pathlist=$(<"$3")
       	shift ;	shift ;	shift
      else
        from_file=false
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --unstage )
      command='unstage'
      if [[ $2 =~ ^--from-?file ]] ; then
        from_file=true
        pathlist=$(<"$3")
        shift ; shift ; shift
      else
        from_file=false
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --events )
      command='events'
      channelname="$2"
      path="$3"
      shift ; shift ; shift
      ;;
    --report-staged )
      command='report-staged'
      channelname="$2"
      path="$3"
      shift ; shift ; shift
      ;;
    --recursive )
      recursive=true
      shift
      ;;
    --force )
      force=true
      shift
      ;;
    --lifetime )
      arg="$2"
      lifetime=${arg::${#arg} -1}
      lifetime_unit=${arg: ${#arg}-1}
      shift ; shift 
      ;;        
    --timeout )
      channel_timeout="$2"
      shift ; shift
      ;;
    --channels )
      command='channels'
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a channel name
          ;;
        * )
          # This must be a channel name
          channelname="$2"
          shift
          ;;
      esac
      shift
      ;;
    --space )
      command='space'
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a poolgroup name
          ;;
        * )
          # This must be a poolgroup
          poolgroup="$2"
          shift
          ;;
      esac
      shift
      ;;
    --debug )
      debug=true
      shift
      ;;
    *)
      echo 1>&2 "ERROR: unknown option '$1'."
      usage
      ;;
  esac
done



#
# Validate input
#

# Check lifetime
if ! [[ "$lifetime" =~ ^[0-9]+$ ]] ; then
   echo 1>&2 "ERROR: lifetime is not given in correct format."
   exit 1
fi
case $lifetime_unit in
  S )
    lifetime_unit=SECONDS
    ;;
  M )
    lifetime_unit=MINUTES  
    ;;
  H )
    lifetime_unit=HOURS
    ;;
  D )
    lifetime_unit=DAYS
    ;;
  * )
    echo 1>&2 "ERROR: lifetime unit is '$lifetime_unit' but should be S, M, H, or D."
    exit 1
    ;;
esac

# We need some external commands.
for external_command in curl jq sed grep column sort tr ; do
  if ! command -v "$external_command" >/dev/null 2>&1 ; then
    echo >&2 "ERROR: I require '$external_command' but it's not installed."
    exit 1
  fi
done


check_macaroon () {
  # Checks, if possible, whether a macaroon is still valid.
  local macaroon="$1"
  if [ -x "${script_dir}/view-macaroon" ] ; then
    macaroon_viewer="${script_dir}/view-macaroon"
  else
    macaroon_viewer="$(command -v view-macaroon)"
  fi
  if [ -x "$macaroon_viewer" ] ; then
    $debug && echo "Macaroon viewer: $macaroon_viewer"
    endtime=$(
      $macaroon_viewer <<<"$macaroon" \
      | sed -n 's/cid before:// p'
    )
    if [ -n "$endtime" ] ; then
      case $OSTYPE in
        darwin* )  endtime_unix=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${endtime:0:19}" +"%s")  ;;
        * )        endtime_unix=$(date --date "$endtime" +%s)  ;;
      esac
      now_unix=$(date +%s)
      if [ "$now_unix" -gt "$endtime_unix" ] ; then
        echo 1>&2 "ERROR: Macaroon is invalid: it expired on $endtime."
        return 1
      else
        $debug && echo "Macaroon has not expired yet."
      fi
    else
      $debug && echo "Could not get token endtime. It may not be a macaroon."
    fi
  else
    $debug && echo "No view-macaroon found; unable to check macaroon."
  fi
  return 0
}


# If the API address ends with a /, strip it
if [[ $api =~ /$ ]] ; then
  echo 1>&2 "WARNING: stripping trailing slash from API address ($api)."
  api=${api%/}
fi


if [[ ! $api =~ ^https://.*/api/v[12]$ ]] ; then
  echo 1>&2 "WARNING: the API address ($api) should start with 'https://' and end with '/api/v1'."
fi


case $auth_method in
  token )
    if [ -n "$tokenfile" ] ; then 
      if ! [ -f "$tokenfile" ] ; then
        echo 1>&2 "ERROR: specified tokenfile does not exist."
        exit 1
      fi

      token=$(sed -n 's/^bearer_token *= *//p' "$tokenfile")
      if [ "$(wc -l <<<"$token")" -gt 1 ] ; then
        echo 1>&2 "ERROR: file '$tokenfile' contains multiple tokens."
        exit 1
      fi
      # If it was not an rclone config file, it may be a 
      # plain text file with only the token.
      if [ -z "$token" ] ; then
        token=$(head -n 1 "$tokenfile")
      fi
      if [ -z "$token" ] ; then
        echo 1>&2 "ERROR: could not read token from tokenfile."
        exit 1
      fi
    elif ! [ -n "$token" ] ; then
      echo 1>&2 "ERROR: no tokenfile, nor variable BEARER_TOKEN specified."
      exit 1
    fi
    check_macaroon "$token" || exit 1
    ;;
  netrc )
    if [ ! -f "$netrcfile" ] ; then
      echo 1>&2 "ERROR: could not open netrc file '$netrcfile'."
      exit 1
    fi
    ;;
  proxy )
    if [ ! -f "$proxyfile" ] ; then
      echo 1>&2 "ERROR: could not open proxy '$proxyfile'."
      exit 1
    fi
    if [ ! -d "$certdir" ] ; then
      echo 1>&2 "ERROR: could not find '$certdir'." \
           "Please install the Grid root certificates if you want to use your proxy."
      exit 1
    fi
    # Check if the proxy is still valid; if not, exit after the error message.
    if [ -x "$(command -v voms-proxy-info)" ]; then
      voms-proxy-info --exists --file "$proxyfile" 1>&2 || exit 1
    fi
    ;;
  * )
    echo 1>&2 "ERROR: you have to specify a valid authentication method."
    exit 1
    ;;
esac


case $command in
  list | stat | mkdir | mv | delete | events | report-staged )
    if [[ -z $path || $path =~ ^-- ]] ; then
      echo 1>&2 "ERROR: command $command requires a path."
      exit 1
    fi
    case $command in
      mv )
        if [[ -z $destination || $destination =~ ^-- ]] ; then
          echo 1>&2 "ERROR: command $command requires a destination."
          exit 1
        fi
        ;;
      events )
        if [[ -z $channelname || $channelname =~ ^-- ]] ; then
          echo 1>&2 "ERROR: command $command requires a channel name."
          exit 1
        fi
        ;;
    esac
    ;;
  longlist | checksum | stage | unstage )
    if [[ -z $pathlist || $pathlist =~ ^-- ]] ; then
      echo 1>&2 "ERROR: command $command requires a path or a path list."
      exit 1
    fi
    ;;
  '' )
    echo 1>&2 "ERROR. Please specify a command. See --help for more information."
    exit 1
    ;;
  whoami | channels | space )
    ;;
  * )
    echo 1>&2 "ERROR: command '$command' is not implemented."
    exit 1
    ;;
esac

if [ -z "$api" ] ; then
  echo 1>&2 "ERROR: no API specified. Use --api <api> or specify a default API in one of the configuration files (" \
       "${configfiles[@]}" \
       ")."
  exit 1
fi

#
# End of input validation
#



#
# Set up dir for settings, channel state info, curl authentication headers, and request logfile
#
ada_dir=~/.ada
requests_log="$ada_dir"/requests.log
mkdir -p "$ada_dir"/headers
mkdir -p "$ada_dir"/channels
touch "$requests_log"
chmod -R u=rwX,g=,o= "$ada_dir"



#
# Construct the authorization part of the curl command.
#
case $auth_method in
  token )
    # We can't specify the token as a command line argument,
    # because others could read that with the ps command.
    # So we have to put the authorization header in a temporary file.
    case $OSTYPE in
      darwin* )  curl_authorization_header_file=$(mktemp "$ada_dir"/headers/authorization_header_XXXXXXXXXXXX)     ;;
      * )        curl_authorization_header_file=$(mktemp -p "$ada_dir"/headers authorization_header_XXXXXXXXXXXX)  ;;
    esac
    chmod 600 "$curl_authorization_header_file"
    # File should be cleaned up when we're done,
    # unless we're debugging
    if $debug ; then
      trap "{
              echo
              echo 'WARNING: in debug mode, the authorization header file' \
                   '$curl_authorization_header_file will not be cleaned up.' \
                   'Please clean it up yourself.'
            }" EXIT
    else
      trap 'rm -f "$curl_authorization_header_file"' EXIT
    fi
    # Save the header in the file
    echo "header \"Authorization: Bearer $token\"" > "$curl_authorization_header_file"
    # Refer to the file with the header
    curl_authorization=( "--config" "$curl_authorization_header_file" )
    ;;
  netrc )
    curl_authorization=( "--netrc-file" "$netrcfile" )
    ;;
  proxy )
    curl_authorization=( --capath "$certdir"
                         --cert   "$proxyfile"
                         --cacert "$proxyfile" )
    ;;
esac



#
# Import functions we need.
#
. "${script_dir}"/ada_functions.inc



#
# Execute API call(s).
#

case $command in
  whoami )
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           -X GET "$api/user"
    ) \
    | jq .
    ;;
  list )
    type=$(pathtype "$path")
    case $type in
      DIR )
        (
          $debug && set -x   # If --debug is specified, show (only) curl command
          curl "${curl_authorization[@]}" \
               "${curl_options_common[@]}" \
               -X GET "$api/namespace/$(urlencode "$path")?children=true" \
          || { echo "API call failed." 1>&2 ; exit 1 ; }
        ) \
        | jq -r '.children | .[] | [ .fileName , .fileType ] | @tsv' \
        | sed -e $'s@\tREGULAR@@' \
              -e $'s@\tDIR@/@' \
              -e $'s@\tLINK@@' \
        | sort
        ;;
      REGULAR | LINK )
        # User asked listing of a regular file (not a dir).
        # No addition data is needed, the pathtype function 
        # has already checked that the file exists;
        # So we only list the file name. Nothing more.
        echo "$path"
        ;;
      '' )
        # The path may not exist, or we may not have permission to see it.
        echo "Warning: could not determine object type for '$path'"
        ;;
      * )
        echo "Unknown object type '$type'. Please create an issue for this in Github."
        ;;
    esac
    ;;
  longlist )
    while read -r path ; do
      type=$(pathtype "$path")
      encoded_path=$(urlencode "$path")
      case $type in
        DIR )
          (
            $debug && set -x   # If --debug is specified, show (only) curl command
            curl "${curl_authorization[@]}" \
                 "${curl_options_common[@]}" \
                 -X GET "$api/namespace/$encoded_path?children=true&locality=true&qos=true"
          ) \
          | jq -r '.children | .[]
                   | [ .fileName ,
                       .fileType ,
                       .size ,
                       (.mtime / 1000 | strftime("%Y-%m-%d %H:%M UTC")) ,
                       if .targetQos then (.currentQos + "→" + .targetQos) else .currentQos end ,
                       .fileLocality ]
                   | @tsv' \
          | sed -e $'s@\tREGULAR@@' \
                -e $'s@\tDIR@/@' \
                -e $'s@\tLINK@§@'
          # Note: it would be better to use strflocaltime instead of strftime,
          # but that requires a newer version of jq than Centos 7 has.
          ;;
        REGULAR | LINK )
          (
            $debug && set -x   # If --debug is specified, show (only) curl command
            curl "${curl_authorization[@]}" \
                 "${curl_options_common[@]}" \
                  -X GET "$api/namespace/$encoded_path?locality=true&qos=true"
          ) \
          | jq -r '[ .size ,
                     (.mtime / 1000 | strftime("%Y-%m-%d %H:%M UTC")) ,
                     if .targetQos then (.currentQos + "→" + .targetQos) else .currentQos end ,
                     .fileLocality ]
                   | @tsv' \
          | sed -e "s@^@$path\t@"
          ;;
        '' )
          # The path may not exist, or we may not have permission to see it.
          echo "Warning: could not determine object type for '$path'"
          ;;
        * )
          echo "Unknown object type '$type'. Please create an issue for this in Github."
          ;;
      esac
    done <<<"$pathlist" \
    | column -t -s $'\t' \
    | sort
    ;;    
  stat )
    pnfsid=$(get_pnfsid "$path")
    if [ -z "$pnfsid" ] ; then
      echo 1>&2 "ERROR: could not get file properties."
      exit 1
    fi
    (
      $debug && set -x
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           -X GET "$api/id/$pnfsid"
    ) \
    | jq .
    ;;
  mkdir )
    create_path $path $recursive
    ;;
  mv )
    # dCache may overwrite an empty directory.
    # If target already exists, quit.
    case $(pathtype "$destination") in
      DIR | REGULAR | LINK )
        echo 1>&2 "ERROR: target '$destination' already exists."
        exit 1
        ;;
    esac
    encoded_path=$(urlencode "$path")
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           "${curl_options_post[@]}" \
           -X POST "$api/namespace/$encoded_path" \
           -d "{\"action\":\"mv\",\"destination\":\"$destination\"}"
    ) \
    | jq -r .status
    ;;
  delete )
    case $(pathtype "$path") in
      REGULAR | LINK )
        delete_path "$path" "$recursive" "$force"
        ;;
      DIR )
        if $recursive || ! dir_has_items "$path" ; then
          delete_path "$path" "$recursive" "$force"
        else
          echo "WARNING: directory '$path' is not empty. If you want to remove it" \
               "and its contents, you can add the --recursive argument."
          exit 1
        fi
        ;;
      '' )
        # The path may not exist, or we may not have permission to see it.
        echo "Warning: could not determine object type for '$path'"
        ;;
      * )
        echo "Unknown object type '$type'. Please create an issue for this in Github."
        ;;
    esac
    ;;
  checksum )
    while read -r path ; do
      type=$(pathtype "$path")
      case $type in
        DIR )
          # It's a directory. Show checksums for files in directory.
          with_files_in_dir_do get_checksums "$path" "$recursive"
          ;;
        REGULAR )
          # It's a file. Show its checksums.
          get_checksums "$path"
          echo
          ;;
        '')
          echo "Warning: could not determine type of object '$path'."
          ;;
        LINK )
          # Do nothing
          ;;
        * )
          echo "Unknown object type '$type'. Please create an issue for this in Github."
          ;;
      esac
    done <<<"$pathlist"
    ;;
  stage | unstage )
    case $command in
      stage   )  activity='PIN'     ;;
      unstage )  activity='UNPIN'   ;;
    esac
    bulk_request "$activity" "$pathlist" "$recursive" | column -t -s $'\t'
    ;;
  events | report-staged )
    if [ "${BASH_VERSINFO[0]}" -lt 4 ] ; then
      echo 1>&2 "ERROR: your bash version is too old: $BASH_VERSION." \
           "You need version 4 or newer to use this Ada option."
      case $OSTYPE in
        darwin* )
          echo 1>&2 "Please install a newer bash with:"
          echo 1>&2 "    brew install bash"
          ;;
        * )
          echo 1>&2 "Please use a system with a newer bash version."
          ;;
      esac
      exit 1
    fi
    channel=$(get_channel_by_name "$channelname")
    if [ "$channel" = "" ] ; then
      # Channel doesn't exist; create it.
      (
        $debug && set -x
        curl "${curl_authorization[@]}" \
             "${curl_options_common[@]}" \
             "${curl_options_post[@]}" \
             -X POST "$api/events/channels" -d "{\"client-id\":\"$channelname\"}"
      )
      channel=$(get_channel_by_name "$channelname")
      # There is no API call to translate channel ID back to
      # channel name. So we keep track of the name ourselves.
      channel_id=$(basename "$channel")
      echo "$channelname" > "${ada_dir}/channels/channel-name-${channel_id}"
      # Set channel timeout
      (
       	$debug && set -x
        curl "${curl_authorization[@]}" \
             "${curl_options_common[@]}" \
             "${curl_options_post[@]}" \
             -X PATCH "$channel" \
             -d "{\"timeout\": $channel_timeout}"
      )
    fi
    echo "Channel: $channel"
    channel_subscribe "$channel" "$path" "$recursive"
    for subscription in $(get_subscriptions_by_channel "$channel") ; do
      list_subscription "$subscription"
    done
    case $command in
      events )
        echo "Following..."
        ;;
      report-staged )
        echo "Listing initial file status..."
        list_online_files "$path" "$recursive"
        echo "Listening for file status changes..."
        ;;
    esac
    follow_channel "$channel"
    ;;
  channels )
    first=true
    get_channels "$channelname" \
    | while read -r channel ; do
      # Show empty line between channels
      ! $first && echo
      first=false
      # Show channel ID
      echo -n "$(basename "$channel")"
      # Show channel name, if that was saved locally
      # (There is no API call to retrieve the channel name)
      channel_id=$(basename "$channel")
      if [ -f "${ada_dir}/channels/channel-name-${channel_id}" ] ; then
        channelname=$(< "${ada_dir}/channels/channel-name-${channel_id}")
        echo -n "  name=$channelname"
      fi
      # Show channel properties (for now only the timeout)
      channel_properties=$(
         curl "${curl_authorization[@]}" \
              "${curl_options_common[@]}" \
              -X GET "$channel" \
         | jq -r 'to_entries[] | [.key, .value] | @tsv' \
         | tr '\t' '='
      )
      # Show event ID, if available
      channel_status_file="${ada_dir}/channels/channel-status-${channel_id}"
      if [ -f "$channel_status_file" ] ; then
        last_event_id=$(grep -E --max-count=1 --only-matching \
                             '[0-9]+' "$channel_status_file")
        if [ -n "$last_event_id" ] ; then
          echo -n "  last-event-id=$last_event_id"
        fi
      fi
      echo "  $channel_properties"
      # Next, show all subscribed paths in this channel.
      get_subscriptions_by_channel "$channel" \
      | while read -r subscription ; do
        {
          echo -n "$(basename "$subscription")  "
          list_subscription "$subscription"
        }
      done \
      | sort -k 2,2 \
      | sed -e 's/^/  /'
    done
    ;;
  space )
    if [ -z "$poolgroup" ] ; then
      (
        $debug && set -x
        curl "${curl_authorization[@]}" \
             "${curl_options_common[@]}" \
             -X GET "$api/poolgroups" \
        | jq -r '.[] | .name'
      )
    else
      (
        $debug && set -x
        curl "${curl_authorization[@]}" \
             "${curl_options_common[@]}" \
             -X GET "$api/poolgroups/$poolgroup/space" \
        | jq '.groupSpaceData'
      )
    fi
    ;;
  * )
    echo "Command '$command' is not implemented (yet)."
    ;;
esac
