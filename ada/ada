#!/bin/bash

# This script talks to the dCache API.
#
# Design: Natalie & Onno, SURFsara.
#
# Latest version is available at: https://github.com/sara-nl/SpiderScripts
#
# Changes:
# 2020-01-28 - Onno    - Created
# 2020-02-14 - Onno    - Support for server-sent events
# 2020-02-18 - Onno    - Recursion with server-sent events
# 2020-02-24 - Onno    - Don't show bearer tokens on command line
# 2020-03-04 - Onno    - Added X509 proxy authentication and netrc authentication
# 2020-03-11 - Onno    - Added recursive deletes
# 2020-03-13 - Onno    - Get server-sent events for files being staged
# 2020-04-03 - Onno    - Add --stat to get all possible file/dir info
# 2020-04-16 - Onno    - Add --recursive to --stage, --unstage, --checksum

usage() {
  cat <<-EOF
	ADA - Access dCache API to manage your data.
	Usage: $0 [general options...] [authentication] <command> [command options]

	General options:

	  --api
	      The dCache API URL to talk to.

	  --debug
	      Show what's going on.

	Authentication options:

	  --tokenfile <filename>
	      Authenticate with the token in this file.
	      This can be an rclone config file with a
	      bearer_token statement, or a plain file with
	      only the token.

	  --netrc [filename]
	      Authenticate with a curl netrc file
	      containing username and password.
	      If no filename was provided, use ~/.netrc.

	  --proxy [filename]
	      Authenticate with a Grid proxy.
	      If no filename was provided, use \$X509_USER_PROXY.

	Commands:

	  --help
	      Show this helptext.

	  --whoami
	      Show how dCache identifies you.

	  --list <directory>
	      List a directory.

	  --longlist <file|directory>
	      List a file or directory with details.
	  --longlist --from-file <file-list>
	      List the files or directories specified in the given file.

	  --stat <file|directory>
	      Show all details of file or dir.

	  --mkdir <directory>
	      Create a directory.

	  --mv <file|directory> <destination>
	      Rename or move a file or directory.

	  --delete <file|directory> [--recursive [--force]]
	      Delete a file or directory.
	      To recursively delete a directory and ALL of its
	      contents, add --recursive. You will need to confirm
	      deletion of each subdir, unless you add --force.
	      Please note, that dCache storage systems usually
	      don't have an undelete option.

	  --checksum <file>
	      Show MD5/Adler32 checksums for file.
	  --checksum <directory> [--recursive]
	      Show MD5/Adler32 checksums for files in directory.
	  --checksum --from-file <file-list>
	      Show MD5/Adler32 checksums for files in the list.

	  --stage <file>
	      Stage a file from tape (restore, bring it online).
	  --stage <directory> [--recursive]
	      Stage files in directory.
	  --stage --from-file <file-list>
	      Stage files in the list.

	  --unstage <file>
	      Release file so dCache may purge its online replica.
	  --unstage <directory> [--recursive]
	      Release files in directory.
	  --unstage --from-file <file-list>
	      Release files in the list.

	  --events <channel-name> <path-to-follow> [--recursive] [--timeout s]
	      Subscribe to changes in the given direcory,
	      using server-sent events (SSE).
	      When --recursive is added, all subdirectories will be
	      followed as well, including any new subdirectories
	      that will be created.
	      With --timeout a timeout in seconds can be set. When
	      a channel is not being followed, dCache may clean it up
	      after this timeout. Events that have not been processed
	      will then be lost.

	  --report-staged <channel-name> <path-to-follow> [--recursive] [--timeout s]
	      Subscribe to stage (bring online) events in a directory,
	      using server-sent events (SSE).
	      This command is slightly different from --events:
	      When you start it, all files in the scope will be listed,
	      including their locality and QoS. This allows your event
	      handler to take actions, like starting jobs to process
	      the files that are online.
	      When all files have been listed, the command will keep
	      listening and reporting all locality and QoS changes.
	      The --recursive and --timeout flags work as with --events.

	  --channels [channel-name]
	      List your existing channels and their properties.
	      If the channel name is given, list channel(s) with that name.

	Examples:
	  $0 ... (todo)

	Default values can be stored in /etc/ada.conf and ~/.ada/ada.conf.
	For example:
	api='https://prometheus.desy.de:3880/api/v1/'

	EOF
  exit 1
}


# Set default values
api=
debug=false
channel_timeout=3600
auth_method=

# Load defaults from configuration file if exists
declare -a configfiles=( /etc/ada.conf ~/.ada/ada.conf )
for configfile in ${configfiles[@]} ; do
  if [ -f "$configfile" ] ; then
    $debug && echo "Loading $configfile"
    source "$configfile"
  fi
done

# If no arguments are provided, show help.
if [ -z "$1" ] ; then
  usage
fi

# Initialize some vars we don't want to be overridden in config files
command=
path=
recursive=false
force=false

# Process command line arguments
while [ $# -gt 0 ] ; do
  case "$1" in
    --help | -help | -h )
      usage
      ;;
    --tokenfile )
      auth_method=token
      tokenfile="$2"
      shift ; shift
      ;;
    --netrc )
      auth_method=netrc
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a file name
          netrcfile=~/.netrc
          ;;
        * )
          # This must be a file name
          netrcfile="$2"
          shift
          ;;
      esac
      shift
      ;;
    --proxy )
      auth_method=proxy
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a file name
          proxyfile="$X509_USER_PROXY"
          ;;
        * )
          # This must be a file name
          proxyfile="$2"
          shift
          ;;
      esac
      shift
      ;;
    --api )
      api="$2"
      shift ; shift
      ;;
    --whoami )
      command=whoami
      shift
      ;;
    --list )
      command=list
      path="$2"
      shift ; shift
      ;;
    --longlist )
      command=longlist
      if [ "$2" = "--from-file" ] ; then
        $debug && echo "Reading list '$3'"
        pathlist=$(<"$3")
        shift ; shift ; shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --stat )
      command=stat
      path="$2"
      shift ; shift
      ;;
    --mkdir )
      command=mkdir
      path="$2"
      shift ; shift
      ;;
    --mv )
      command=mv
      path="$2"
      destination="$3"
      shift ; shift ; shift
      ;;
    --delete )
      command=delete
      path="$2"
      shift ; shift
      ;;
    --checksum )
      command=checksum
      if [ "$2" = "--from-file" ] ; then
       	pathlist=$(<"$3")
        shift ; shift ; shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --stage )
      command=stage
      if [[ $2 =~ ^--from-?file ]] ; then
        pathlist=$(<"$3")
       	shift ;	shift ;	shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --unstage )
      command=unstage
      if [[ $2 =~ ^--from-?file ]] ; then
        pathlist=$(<"$3")
        shift ; shift ; shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --events )
      command=events
      channelname="$2"
      path="$3"
      shift ; shift ; shift
      ;;
    --report-staged )
      command=report-staged
      channelname="$2"
      path="$3"
      shift ; shift ; shift
      ;;
    --recursive )
      recursive=true
      shift
      ;;
    --force )
      force=true
      shift
      ;;
    --timeout )
      channel_timeout="$2"
      shift ; shift
      ;;
    --channels )
      command=channels
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a channel name
          ;;
        * )
          # This must be a channel name
          channelname="$2"
          shift
          ;;
      esac
      shift
      ;;
    --debug )
      debug=true
      shift
      ;;
    *)
      echo "ERROR: unknown option '$1'."
      usage
      ;;
  esac
done



#
# Validate input
#

# We need some external commands.
for external_command in curl jq sed grep column sort tr ; do
  if ! command -v "$external_command" >/dev/null 2>&1 ; then
    echo >&2 "ERROR: I require '$external_command' but it's not installed."
    exit 1
  fi
done

case $auth_method in
  token )
    if [ -z "$tokenfile" ] ; then
      echo "ERROR: no tokenfile specified."
      exit 1
    fi

    token=$(sed -n 's/^bearer_token *= *//p' "$tokenfile")
    if [ $(wc -l <<<"$token") -gt 1 ] ; then
      echo "ERROR: file '$tokenfile' contains multiple tokens."
      exit 1
    fi
    # If it was not an rclone config file, it may be a 
    # plain text file with only the token.
    if [ -z "$token" ] ; then
      token=$(head -n 1 "$tokenfile")
    fi
    if [ -z "$token" ] ; then
      echo "ERROR: could not read token from tokenfile."
      exit 1
    fi
    ;;
  netrc )
    if [ ! -f "$netrcfile" ] ; then
      echo "ERROR: could not open netrc file '$netrcfile'."
      exit 1
    fi
    ;;
  proxy )
    if [ ! -f "$proxyfile" ] ; then
      echo "ERROR: could not open proxy '$proxyfile'."
      exit 1
    fi
    if [ ! -d /etc/grid-security/certificates ] ; then
      echo "ERROR: could not find /etc/grid-security/certificates/." \
           "Please install the Grid root certificates if you want to use your proxy."
      exit 1
    fi
    ;;
  * )
    echo "ERROR: you have to specify a valid authentication method."
    exit 1
    ;;
esac


case $command in
  list | stat | mkdir | mv | delete | events | report-staged )
    if [[ -z $path || $path =~ ^-- ]] ; then
      echo "ERROR: command $command requires a path."
      exit 1
    fi
    case $command in
      mv )
        if [[ -z $destination || $destination =~ ^-- ]] ; then
          echo "ERROR: command $command requires a destination."
          exit 1
        fi
        ;;
      events )
        if [[ -z $channelname || $channelname =~ ^-- ]] ; then
          echo "ERROR: command $command requires a channel name."
          exit 1
        fi
        ;;
    esac
    ;;
  longlist | checksum | stage | unstage )
    if [[ -z $pathlist || $pathlist =~ ^-- ]] ; then
      echo "ERROR: command $command requires a path or a path list."
      exit 1
    fi
    ;;
  '' )
    echo "ERROR. Please specify a command. See --help for more information."
    exit 1
    ;;
  whoami | channels )
    ;;
  * )
    echo "ERROR: command '$command' is not implemented."
    exit 1
    ;;
esac

if [ -z "$api" ] ; then
  echo "ERROR: no API specified. Use --api <api> or specify a default API in one of the configuration files (${configfiles[@]})."
  exit 1
fi

#
# End of input validation
#



#
# Construction of curl command arguments.
# These are put in arrays for easier handling of quotes.
#

# Construct the authorization part of the curl command.
case $auth_method in
  token )
    # We can't specify the token as a command line argument,
    # because others could read that with the ps command.
    # So we have to put the authorization header in a temporary file.
    mkdir -p ~/.ada/headers
    chmod 700 ~/.ada
    chmod 700 ~/.ada/headers
    case $OSTYPE in
      darwin* )  curl_authorization_header_file=$(mktemp ~/.ada/headers/authorization_header_XXXXXXXXXXXX)     ;;
      * )        curl_authorization_header_file=$(mktemp -p ~/.ada/headers authorization_header_XXXXXXXXXXXX)  ;;
    esac
    chmod 600 "$curl_authorization_header_file"
    # File should be cleaned up when we're done,
    # unless we're debugging
    if $debug ; then
      trap "{
              echo
              echo 'WARNING: in debug mode, the authorization header file' \
                   '$curl_authorization_header_file will not be cleaned up.' \
                   'Please clean it up yourself.'
            }" EXIT
    else
      trap 'rm -f "$curl_authorization_header_file"' EXIT
    fi
    # Save the header in the file
    echo "header \"Authorization: Bearer $token\"" > "$curl_authorization_header_file"
    # Refer to the file with the header
    curl_authorization=( "--config" "$curl_authorization_header_file" )
    ;;
  netrc )
    curl_authorization=( "--netrc-file" "$netrcfile" )
    ;;
  proxy )
    curl_authorization=( --capath /etc/grid-security/certificates 
                         --cert   "$proxyfile"
                         --cacert "$proxyfile" )
    ;;
esac

# Other curl arguments
curl_options_common=(
                      -H "accept: application/json"
                      --fail --silent --show-error
                    )
curl_options_no_errors=(
                      -H "accept: application/json"
                      --fail --silent
                    )
curl_options_post=(
                    -H "content-type: application/json"
                  )
curl_options_stream=(
                      -H 'accept: text/event-stream'
                      --no-buffer
                      --fail --silent --show-error
                    )

#
# Define functions we need.
#

urlencode () {
  # We use jq for encoding the URL, because we need jq anyway.
  $debug && echo "urlencoding '$1' to '$(printf "$1" | jq -sRr @uri)'" 1>&2
  printf "$1" | jq -sRr @uri
}


pathtype () {
  local path=$(urlencode "$1")
  curl "${curl_authorization[@]}" \
       "${curl_options_no_errors[@]}" \
       -X GET "$api/namespace/$path" \
  | jq -r .fileType
}


get_pnfsid () {
  local path=$(urlencode "$1")
  curl "${curl_authorization[@]}" \
       "${curl_options_no_errors[@]}" \
       -X GET "$api/namespace/$path" \
  | jq -r .pnfsId
}


is_online () {
  # Checks whether a file is online.
  # The locality should be ONLINE or ONLINE_AND_NEARLINE.
  local path=$(urlencode "$1")
  curl "${curl_authorization[@]}" \
       "${curl_options_no_errors[@]}" \
       -X GET "$api/namespace/$path?locality=true&qos=true" \
  | jq -r '.fileLocality' \
  | grep --silent 'ONLINE'
}


get_subdirs () {
  local path=$(urlencode "$1")
  curl "${curl_authorization[@]}" \
       "${curl_options_common[@]}" \
       -X GET "$api/namespace/$path?children=true" \
  | jq -r '.children | .[] | if .fileType == "DIR" then .fileName else empty end'
}


get_files_in_dir () {
  local path=$(urlencode "$1")
  curl "${curl_authorization[@]}" \
       "${curl_options_common[@]}" \
       -X GET "$api/namespace/$path?children=true" \
  | jq -r '.children | .[] | if .fileType == "REGULAR" then .fileName else empty end'
}


get_children () {
  local path=$(urlencode "$1")
  curl "${curl_authorization[@]}" \
       "${curl_options_common[@]}" \
       -X GET "$api/namespace/$path?children=true" \
  | jq -r '.children | .[] | .fileName'
}


dir_has_items () {
  path="$1"
  get_children "$path" | grep --silent --max-count 1 '.'
}


get_confirmation () {
  prompt="$1"
  while true ; do
    # We read the answer from tty, otherwise strange things would happen.
    read -p "$prompt (N/y) " -n1 answer < /dev/tty
    echo
    case $answer in
      Y | y )       return 0  ;;
      N | n | '' )  return 1  ;;
    esac
  done
}


delete_path () {
  local path="$1"
  local recursive="$2"
  local force="$3"
  case $recursive in
    true | false ) ;;  # No problem
    * )
      echo "ERROR: delete_path: recursive is '$recursive' but should be true or false."
      exit 1
      ;;
  esac
  path_type=$(pathtype "$path")
  local aborted=false
  # Are there children in this path we need to delete too?
  if $recursive && [ "$path_type" = "DIR" ] ; then
    if $force || get_confirmation "Delete all items in $path?" ; then
      while read child ; do
        delete_path "$path/$child" "$recursive" "$force" \
        || aborted=true
      done < <(get_children "$path")
    else
      # If the user pressed 'n', dir contents will not be deleted;
      # In that case we should not delete the dir either.
      aborted=true
    fi
  fi
  # Done with the children, now we delete the parent (if not aborted).
  if $aborted ; then
    echo "Deleting $path - aborted."
    # Tell higher level that user aborted,
    # because deleting the parent dir is useless.
    return 1  
  else
    echo -n "Deleting $path - "
    encoded_path=$(urlencode "$path")
    (
      $debug && set -x
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           -X DELETE "$api/namespace/$encoded_path"
    ) \
    | jq -r .status
  fi
}


set_qos () {
  file="$1"
  target="$2"
  encoded_path=$(urlencode "$file")
  $debug || echo -n "$file  "
  (
    $debug && set -x   # If --debug is specified, show (only) curl command
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         "${curl_options_post[@]}" \
         -X POST "$api/namespace/$encoded_path" \
         -d "{\"action\":\"qos\",\"target\":\"$target\"}"
  ) | jq -r .status
}


with_files_in_dir_do () {
  # This will execute a function on all files in a dir.
  # Recursion into subdirs is supported.
  #
  # Arguments:
  # 1. The function to be executed on files;
  # 2. The dir to work on
  # 3. Recursive? (true|false)
  # 3-x. Additional arguments to give to the function
  #      (The first argument to the function is always the file name.)
  #
  local function="$1"
  local path="$2"
  local recursive="$3"
  case $recursive in
    true | false )  ;;  # No problem
    * )
      echo "Error in with_files_in_dir_do: recursive='$recursive'; should be true or false."
      exit 1
      ;;
  esac
  shift ; shift ; shift
  # Run the given command on all files in this directory
  get_files_in_dir "$path" \
  | while read filename ; do
    "$function" "$path/$filename" "$@"
  done
  # If needed, do the same in subdirs
  if $recursive ; then
    get_subdirs "$path" \
    | while read subdir ; do
      with_files_in_dir_do "$function" "$path/$subdir" "$recursive" "$@"
    done
  fi
}


get_checksums () {
  # This function prints out all known checksums of a given file.
  # A file can have Adler32 checksum, MD5 checksum, or both.
  # Output format:
  # /path/file  ADLER32=xxx  MD5_TYPE=xxxxx
  local path="$1"
  encoded_path=$(urlencode "$path")
  {
    echo -n -e "$path\t"
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           -X GET "$api/namespace/$encoded_path"
    ) \
    | jq -r '.pnfsId' \
    | {
        read pnfsid
        if [ -z "$pnfsid" ] ; then
          continue  # skip to next $path
        fi
        (
          $debug && set -x
          curl "${curl_authorization[@]}" \
               "${curl_options_common[@]}" \
               -X GET "$api/id/$pnfsid"
        ) \
        | jq -r '.checksums | .[] | [ .type , .value ] | @tsv'
        # jq output is tab separated:
        # ADLER32\txxx
        # MD5_TYPE\txxxxx
      } \
    | sed -e 's/\t/=/g' | tr '\n' '\t'
    echo
  } \
  | sed -e 's/\t/  /g'
}


get_channel_by_name () {
  local channelname="$1"
  channel=$(
             (
               $debug && set -x
               curl "${curl_authorization[@]}" \
                    "${curl_options_common[@]}" \
                    -X GET "$api/events/channels?client-id=$channelname"
              ) \
              | jq -r '.[]'
           )
  channel_count=$(wc -l <<<"$channel")
  if [ "$channel_count" -gt 1 ] ; then
    echo "ERROR: there is more than one channel with that name:"
    echo "$channel"
    exit 1
  fi
  echo "$channel"
}

get_channels () {
  local channelname="$1"
  local query=''
  if [ -n "$channelname" ] ; then
    query="?client-id=$channelname"
  fi
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$api/events/channels${query}"
  ) \
  | jq -r '.[]'
}

channel_subscribe () {
  local channel="$1"
  local path="$2"
  local recursive="$3"
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         "${curl_options_post[@]}" \
         -X POST "$channel/subscriptions/inotify" \
         -d "{\"path\":\"$path\"}"
  )
  if $recursive ; then
    get_subdirs "$path" \
    | while read subdir ; do
      $debug && echo "Subscribing to: $path/$subdir"
      channel_subscribe "$channel" "$path/$subdir" "$recursive"
    done
  fi
}


get_subscriptions_by_channel () {
  local channel="$1"
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$channel/subscriptions"
  ) \
  | jq -r '.[]'
}


list_subscription () {
  # Shows all properties of a subscription. (Could be only a path.)
  local subscription="$1"
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$subscription"
  ) \
  | jq -r 'to_entries[] | [.key, .value] | @tsv' \
  | tr '\t' '='
}


get_path_from_subscription () {
  local subscription="$1"
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$subscription"
  ) \
  | jq -r .path
}


follow_channel () {
  # This function is used for two commands: --events and --report-staged.
  # Much of the functionality is the same, but
  # with --report-staged we're checking only whether files
  # are being brought online.
  local channel="$1"
  declare -A subscriptions
  mkdir -p ~/.ada/channels
  chmod 700 ~/.ada
  chmod 700 ~/.ada/channels
  channel_id=$(basename "$channel")
  channel_status_file=~/.ada/channels/"channel-status-$channel_id"
  # If a file exists with the last event for this channel,
  # We should resume from that event ID.
  if [ -f "$channel_status_file" ] ; then
    last_event_id=$(grep -E --max-count=1 --only-matching \
                         '[0-9]+' "$channel_status_file")
    if [ -n "$last_event_id" ] ; then
      echo "Resuming from $last_event_id"
      last_event_id_header=(-H "Last-Event-ID: $last_event_id")
    fi
  else
    last_event_id_header=()
  fi
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_stream[@]}" \
         -X GET "$channel" \
         "${last_event_id_header[@]}"
  ) \
  | while IFS=': ' read key value ; do
      case $key in
        event )
          case $value in
            inotify | SYSTEM )
              event_type="$value"
              ;;
            * )
              echo "ERROR: don't know how to handle event type '$value'."
              cat  # Read and show everything from stdin
              exit 1
              ;;
          esac
          ;;
        id )
          # Save event number so we can resume later.
          event_id="$value"
          ;;
        data )
          case $event_type in
            inotify )
              $debug && { echo ; echo "$value" | jq --compact-output ; }
              # Sometimes there's no .event.name: 
              # then 'select (.!=null)' will output an empty string.
              object_name=$(jq -r '.event.name | select (.!=null)' <<< "$value")
              mask=$(jq -r '.event.mask | @csv' <<< "$value" | tr -d '"')
              cookie=$(jq -r '.event.cookie | select (.!=null)' <<<"$value")
              subscription=$(jq -r '.subscription' <<< "$value")
              subscription_id=$(basename "$subscription")
              # We want to output not only the file name, but the full path.
              # We get the path from the API, but we cache the result
              # in an array for performance.
              if [ ! ${subscriptions[$subscription_id]+_} ] ; then
                # Not cached yet; get the path and store it in an array.
                subscriptions[$subscription_id]=$(get_path_from_subscription "$subscription")
              fi
              path="${subscriptions[$subscription_id]}"
              #
              # If recursion is requested, we need to start following new directories.
              if $recursive ; then
                if [ "$mask" = "IN_CREATE,IN_ISDIR" ] ; then
                  channel_subscribe "$channel" "$path/$object_name" "$recursive"
                fi
              fi
              #
              # A move or rename operation consists of two events,
              # an IN_MOVED_FROM and an IN_MOVED_FROM, both with
              # a cookie (ID) to relate them.
              if [ -n "$cookie" ] ; then
                cookie_string="  cookie:$cookie"
              else
                cookie_string=
              fi
              # Is the user doing --events or --report-staged? The output differs a lot.
              case $command in
                events )
                  # Here comes the output.
                  echo -e "$event_type  ${path}/${object_name}  ${mask}${cookie_string}"
                  ;;
                report-staged )
                  # User wants to see only the staged files.
                  if [ $(pathtype "${path}/${object_name}") = "REGULAR" ] ; then
                    # Is it an attribute event?
                    if grep --silent IN_ATTRIB <<<"$mask" ; then
                      # Show file properties (locality, QoS, name)
                      encoded_path=$(urlencode "${path}/${object_name}")
                      (
                        $debug && set -x   # If --debug is specified, show (only) curl command
                        curl "${curl_authorization[@]}" \
                             "${curl_options_common[@]}" \
                             -X GET "$api/namespace/$encoded_path?locality=true&qos=true"
                      ) \
                      | jq -r '[ .fileLocality ,
                                 if .targetQos then (.currentQos + "→" + .targetQos) else .currentQos end ,
                                 "'"${path}/${object_name}"'" ]
                               | @tsv' \
                      | sed -e 's/\t/  /g'
                    fi
                  fi
                  ;;
              esac
              #
              # When done with this event's data, save the event ID.
              # This can be used to resume the channel.
              echo "$event_id" > "$channel_status_file"
              ;;
            SYSTEM )
              # For system type events we just want the raw output.
              echo -e "$event_type  $value"              
              ;;
            '' )
              # If we get a data line that was not preceded by an 
              # event line, something is wrong.
              echo "Unexpected data line: '$value' near event ID '$event_id'."
              ;;
          esac
          ;;
        '' )
          # Empty line: this ends the current event.
          event_type=
          ;;
        * )
          echo "ERROR: don't know how to handle '$key: $value'."
          exit 1
          ;;
      esac
  done
}


list_online_files () {
  local path="$1"
  local recursive="$2"
  case $recursive in
    true | false ) ;;  # No problem
    * )
      echo "ERROR: list_online_files: recursive is '$recursive' but should be true or false."
      exit 1
      ;;
  esac
  # Show online files in this dir with locality and QoS
  encoded_path=$(urlencode "$path")
  (
    $debug && set -x   # If --debug is specified, show (only) curl command
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$api/namespace/$encoded_path?children=true&locality=true&qos=true"
  ) \
  | jq -r '.children 
           | .[]
           | if .fileType == "REGULAR" then . else empty end
           | [ .fileLocality ,
               if .targetQos then (.currentQos + "→" + .targetQos) else .currentQos end ,
               "'"$path"'/" + .fileName ]
           | @tsv' \
  | sed -e 's/\t/  /g'
  # If recursion is requested, do the same in subdirs.
  if $recursive ; then
    get_subdirs "$path" \
    | while read subdir ; do
      list_online_files "$path/$subdir" "$recursive"
    done
  fi
}



#
# Execute API call(s).
#

case $command in
  whoami )
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           -X GET "$api/user"
    ) \
    | jq .
    ;;
  list )
    type=$(pathtype "$path")
    case $type in
      DIR )
        (
          $debug && set -x   # If --debug is specified, show (only) curl command
          curl "${curl_authorization[@]}" \
               "${curl_options_common[@]}" \
               -X GET "$api/namespace/$(urlencode "$path")?children=true"
        ) \
        | jq -r '.children | .[] | [ .fileName , .fileType ] | @tsv' \
        | sed -e $'s@\tREGULAR@@' \
              -e $'s@\tDIR@/@' \
              -e $'s@\tLINK@@' \
        | sort
        ;;
      REGULAR | LINK )
        # User asked listing of a regular file (not a dir).
        # No addition data is needed, the pathtype function 
        # has already checked that the file exists;
        # So we only list the file name. Nothing more.
        echo "$path"
        ;;
      '' )
        # No valid object. Do nothing.
        ;;
      * )
        echo "Unknown object type '$type'. Please create an issue for this in Github."
        ;;
    esac
    ;;
  longlist )
    while read path ; do
      type=$(pathtype "$path")
      encoded_path=$(urlencode "$path")
      case $type in
        DIR )
          (
            $debug && set -x   # If --debug is specified, show (only) curl command
            curl "${curl_authorization[@]}" \
                 "${curl_options_common[@]}" \
                 -X GET "$api/namespace/$encoded_path?children=true&locality=true&qos=true"
          ) \
          | jq -r '.children | .[]
                   | [ .fileName ,
                       .fileType ,
                       .size ,
                       (.mtime / 1000 | strftime("%Y-%m-%d %H:%M UTC")) ,
                       if .targetQos then (.currentQos + "→" + .targetQos) else .currentQos end ,
                       .fileLocality ]
                   | @tsv' \
          | sed -e $'s@\tREGULAR@@' \
                -e $'s@\tDIR@/@' \
                -e $'s@\tLINK@§@'
          # Note: it would be better to use strflocaltime instead of strftime,
          # but that requires a newer version of jq than Centos 7 has.
          ;;
        REGULAR | LINK )
          (
            $debug && set -x   # If --debug is specified, show (only) curl command
            curl "${curl_authorization[@]}" \
                 "${curl_options_common[@]}" \
                  -X GET "$api/namespace/$encoded_path?locality=true&qos=true"
          ) \
          | jq -r '[ .size ,
                     (.mtime / 1000 | strftime("%Y-%m-%d %H:%M UTC")) ,
                     if .targetQos then (.currentQos + "→" + .targetQos) else .currentQos end ,
                     .fileLocality ]
                   | @tsv' \
          | sed -e "s@^@$path\t@"
          ;;
      esac
    done <<<"$pathlist" \
    | column -t -s $'\t' \
    | sort
    ;;    
  stat )
    pnfsid=$(get_pnfsid "$path")
    if [ -z "$pnfsid" ] ; then
      echo "ERROR: could not get file properties."
      exit 1
    fi
    (
      $debug && set -x
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           -X GET "$api/id/$pnfsid"
    ) \
    | jq .
    ;;
  mkdir )
    parent=$(urlencode $(dirname "$path"))
    name=$(basename "$path")
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           "${curl_options_post[@]}" \
           -X POST "$api/namespace/$parent" \
           -d "{\"action\":\"mkdir\",\"name\":\"$name\"}"
    ) \
    | jq -r .status
    ;;
  mv )
    # dCache may overwrite an empty directory.
    # If target already exists, quit.
    case $(pathtype "$destination") in
      DIR | REGULAR | LINK )
        echo "ERROR: target '$destination' already exists."
        exit 1
        ;;
    esac
    encoded_path=$(urlencode "$path")
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           "${curl_options_post[@]}" \
           -X POST "$api/namespace/$encoded_path" \
           -d "{\"action\":\"mv\",\"destination\":\"$destination\"}"
    ) \
    | jq -r .status
    ;;
  delete )
    case $(pathtype "$path") in
      REGULAR | LINK )
        delete_path "$path" "$recursive" "$force"
        ;;
      DIR )
        if $recursive || ! dir_has_items "$path" ; then
          delete_path "$path" "$recursive" "$force"
        else
          echo "WARNING: directory '$path' is not empty. If you want to remove it" \
               "and its contents, you can add the --recursive argument."
          exit 1
        fi
        ;;
    esac
    ;;
  checksum )
    while read path ; do
      type=$(pathtype "$path")
      case $type in
        DIR )
          # It's a directory. Show checksums for files in directory.
          with_files_in_dir_do get_checksums "$path" "$recursive"
          ;;
        REGULAR )
          # It's a file. Show its checksums.
          get_checksums "$path"
          echo
          ;;
        '' | LINK )
          # No valid object. Do nothing.
          ;;
        * )
          echo "Unknown object type '$type'. Please create an issue for this in Github."
          ;;
      esac
    done <<<"$pathlist"
    ;;
  stage | unstage )
    case $command in
      stage   )  target='disk+tape'  ;;
      unstage )  target='tape'       ;;
    esac
    while read path ; do
      type=$(pathtype "$path")
      case $type in
        DIR )
          with_files_in_dir_do set_qos "$path" "$recursive" "$target"
          ;;
        REGULAR | LINK )
          set_qos "$path" "$target"
          ;;
        '' )
          # No valid object. Do nothing.
          ;;
        * )
          echo "Unknown object type '$type'. Please create an issue for this in Github."
          ;;
      esac
    done <<<"$pathlist" \
    | column -t -s $'\t'  
    ;;
  events | report-staged )
    channel=$(get_channel_by_name "$channelname")
    if [ "$channel" = "" ] ; then
      # Channel doesn't exist; create it.
      (
        $debug && set -x
        curl "${curl_authorization[@]}" \
             "${curl_options_common[@]}" \
             "${curl_options_post[@]}" \
             -X POST "$api/events/channels" -d "{\"client-id\":\"$channelname\"}"
      )
      channel=$(get_channel_by_name "$channelname")
      # There is no API call to translate channel ID back to
      # channel name. So we keep track of the name ourselves.
      channel_id=$(basename "$channel")
      echo "$channelname" > ~/.ada/channels/"channel-name-$channel_id"
      # Set channel timeout
      (
       	$debug && set -x
        curl "${curl_authorization[@]}" \
             "${curl_options_common[@]}" \
             "${curl_options_post[@]}" \
             -X PATCH "$channel" \
             -d "{\"timeout\": $channel_timeout}"
      )
    fi
    echo "Channel: $channel"
    channel_subscribe "$channel" "$path" "$recursive"
    for subscription in $(get_subscriptions_by_channel "$channel") ; do
      list_subscription "$subscription"
    done
    case $command in
      events )
        echo "Following..."
        ;;
      report-staged )
        echo "Listing initial file status..."
        list_online_files "$path" "$recursive"
        echo "Listening for file status changes..."
        ;;
    esac
    follow_channel "$channel"
    ;;
  channels )
    first=true
    get_channels "$channelname" \
    | while read channel ; do
      # Show empty line between channels
      ! $first && echo
      first=false
      # Show channel ID
      echo -n $(basename "$channel")
      # Show channel name, if that was saved locally
      # (There is no API call to retrieve the channel name)
      channel_id=$(basename "$channel")
      if [ -f ~/.ada/channels/"channel-name-$channel_id" ] ; then
        channelname=$(< ~/.ada/channels/"channel-name-$channel_id")
        echo -n "  name=$channelname"
      fi
      # Show channel properties (for now only the timeout)
      channel_properties=$(
         curl "${curl_authorization[@]}" \
              "${curl_options_common[@]}" \
              -X GET "$channel" \
         | jq -r 'to_entries[] | [.key, .value] | @tsv' \
         | tr '\t' '='
      )
      # Show event ID, if available
      channel_status_file=~/.ada/channels/"channel-status-$channel_id"
      if [ -f "$channel_status_file" ] ; then
        last_event_id=$(grep -E --max-count=1 --only-matching \
                             '[0-9]+' "$channel_status_file")
        if [ -n "$last_event_id" ] ; then
          echo -n "  last-event-id=$last_event_id"
        fi
      fi
      echo "  $channel_properties"
      # Next, show all subscribed paths in this channel.
      get_subscriptions_by_channel "$channel" \
      | while read subscription ; do
        {
          echo -n $(basename "$subscription") " "
          list_subscription "$subscription"
        }
      done \
      | sort -k 2,2 \
      | sed -e 's/^/  /'
    done
    ;;
  * )
    echo "Command '$command' is not implemented (yet)."
    ;;
esac
